
#ifdef TEST

#include "unity.h"
#include "lora.h"
#include "lora_ota.h"
#include "crc.h"

void setUp(void)
{
}

void tearDown(void)
{
}

void test_loRaOtaReceiveHandler_full_flow(void) {
    uint8_t frame_buf[256];
    uint16_t frame_len = 0;
    LORA_OtaStatus_t status;

    // Reset OTA node state
    memset(&ota_node, 0, sizeof(ota_node));
    ota_node.state = OTA_NODE_WAIT_START;
    ota_node.fw_buffer = malloc(1024); // buffer firmware giả lập

    /* B1: START */
    uint8_t start_payload[1] = {0x00};
    status = loRaOtaReceiveHandler(
        OTA_TYPE_START, start_payload, sizeof(start_payload)
    );
    TEST_ASSERT_EQUAL_MESSAGE(
        LORA_OTA_STATUS_PROCESS_START_SUCCESS,
        status,
        "Process START failed!"
    );
    TEST_ASSERT_EQUAL(OTA_NODE_WAIT_HEADER, ota_node.state);
    printf("Processed START → state=%d\n", ota_node.state);

    /* B2: HEADER */
    ota_header_t hdr = {
        .fw_size = 8,
        .chunk_size = 4,
        .fw_crc = 0x1234
    };
    status = loRaOtaReceiveHandler(
        OTA_TYPE_HEADER, (uint8_t *)&hdr, sizeof(hdr)
    );
    TEST_ASSERT_EQUAL_MESSAGE(
        LORA_OTA_STATUS_PROCESS_HEADER_SUCCESS,
        status,
        "Process HEADER failed!"
    );
    TEST_ASSERT_EQUAL(OTA_NODE_RECEIVING_DATA, ota_node.state);
    printf("Processed HEADER → fw_size=%d, chunk=%d\n", ota_node.fw_size, ota_node.chunk_size);

    /* B3: DATA seq=0 */
    uint8_t data_payload[2 + 4] = {0x00, 0x00, 0xDE, 0xAD, 0xBE, 0xEF};
    status = loRaOtaReceiveHandler(
        OTA_TYPE_DATA, data_payload, sizeof(data_payload)
    );
    TEST_ASSERT_EQUAL_MESSAGE(
        LORA_OTA_STATUS_PROCESS_DATA_SUCCESS,
        status,
        "Process DATA seq=0 failed!"
    );
    TEST_ASSERT_EQUAL(4, ota_node.received_bytes);
    printf("Processed DATA seq=0 → received_bytes=%d\n", ota_node.received_bytes);

    /* B4: DATA seq=1 */
    uint8_t data_payload2[2 + 4] = {0x00, 0x01, 0x11, 0x22, 0x33, 0x44};
    status = loRaOtaReceiveHandler(
        OTA_TYPE_DATA, data_payload2, sizeof(data_payload2)
    );
    TEST_ASSERT_EQUAL_MESSAGE(
        LORA_OTA_STATUS_PROCESS_DATA_SUCCESS,
        status,
        "Process DATA seq=1 failed!"
    );
    TEST_ASSERT_EQUAL(8, ota_node.received_bytes);
    TEST_ASSERT_EQUAL(OTA_NODE_WAIT_END, ota_node.state);
    printf("Processed DATA seq=1 → received_bytes=%d, state=%d\n", ota_node.received_bytes, ota_node.state);

    /* B5: END */
    uint8_t end_payload[1] = {0x00};
    status = loRaOtaReceiveHandler(
        OTA_TYPE_END, end_payload, sizeof(end_payload)
    );
    TEST_ASSERT_EQUAL_MESSAGE(
        LORA_OTA_STATUS_PROCESS_END_SUCCESS,
        status,
        "Process END failed!"
    );
    TEST_ASSERT_EQUAL(OTA_NODE_WAIT_SIGNAL_UPDATE, ota_node.state);
    printf("Processed END → state=%d\n", ota_node.state);

    /* B6: SIGNAL_UPDATE */
    // Giả lập CRC đúng
    ota_node.expected_crc = crc_fast(ota_node.fw_buffer, ota_node.received_bytes);
    uint8_t signal_payload[1] = {0x00};
    status = loRaOtaReceiveHandler(
        OTA_TYPE_SIGNAL_UPDATE, signal_payload, sizeof(signal_payload)
    );
    TEST_ASSERT_EQUAL_MESSAGE(
        LORA_OTA_STATUS_PROCESS_SIGNAL_UPDATE_SUCCESS,
        status,
        "Process SIGNAL_UPDATE failed!"
    );
    TEST_ASSERT_EQUAL(OTA_NODE_DONE, ota_node.state);
    printf("Processed SIGNAL_UPDATE → DONE state\n");

    free(ota_node.fw_buffer);
}

//intergration test 

void test_loRaOtaReceiveHandler_from_server_log_full(void)
{
    crc_init();
    LORA_OtaStatus_t st;
    uint8_t frame_buffer[150];
    uint16_t frame_len = 0;
    LORA_frame_t OTA_FSM_Data; // Đã khai báo trong module chính

    /* --- reset context --- */
    memset(&ota_node, 0, sizeof(ota_node));
    ota_node.expected_state = OTA_NODE_WAIT_START;
    ota_node.expected_fw_buffer = (uint8_t*)malloc(2048);
    TEST_ASSERT_NOT_NULL_MESSAGE(ota_node.expected_fw_buffer, "fw_buffer malloc failed");

    /* --- START frame (from log) --- */
    uint8_t FR_START[] = {
        0xAA,0x02,0x00,0x00,0x01,0x00,0x6A,0x9E,0xF1,0x0A,0xBB
    };
    {
        memset(&OTA_FSM_Data, 0, sizeof(OTA_FSM_Data));
        frame_len = sizeof(FR_START) / sizeof(FR_START[0]);
        // printf("Length: %u \n",frame_len );
        // printf("Payload header ");
        // for (uint16_t i = 0; i < frame_len; i++) {
        // printf("%02X ", FR_START[i]);
        // }
        // printf("\n End Payload header");

        LORA_Frame_Status_t decode_status = loRaDecodeFrame(FR_START, frame_len, &OTA_FSM_Data);
        printf("CRC Caculate: %02X \n ",OTA_FSM_Data.crc);
        // printf("\n output data length %u \n", OTA_FSM_Data.data_len);
        TEST_ASSERT_EQUAL(LORA_STATUS_DECODE_FRAME_SUCCESS, decode_status);

        st = loRaOtaReceiveHandler(OTA_TYPE_START, OTA_FSM_Data.data_payload , OTA_FSM_Data.data_len);
        TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_START_SUCCESS, st, "START failed");
    }

    /* --- HEADER frame (from log) --- */
    static uint8_t FR_HEADER[] = {
        0xAA,0x02,0x01,0x00,0x0C,
        0x12,0x34,             // session_id
        0x06,0x40,             // fw_size = 1600
        0x00,0x80,             // chunk_size = 128
        0x00,0x0D,             // total_chunks = 13
        0x35,0xEE,0x02,0x1E,   // fw_crc
        0xBC,0x27,0x2C,0xA0,   // CRC (as logged) / trailer
        0xBB
    };
    {
        memset(&OTA_FSM_Data, 0, sizeof(OTA_FSM_Data));
        frame_len = sizeof(FR_HEADER) / sizeof(FR_HEADER[0]);
        
        LORA_Frame_Status_t decode_status = loRaDecodeFrame(FR_HEADER, frame_len, &OTA_FSM_Data);
        TEST_ASSERT_EQUAL(LORA_STATUS_DECODE_FRAME_SUCCESS, decode_status);
        
        st = loRaOtaReceiveHandler(OTA_TYPE_HEADER, OTA_FSM_Data.data_payload, OTA_FSM_Data.data_len);
       
        TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_HEADER_SUCCESS, st, "HEADER failed");
    }

    // Chuyển đổi tất cả frames từ log thành byte arrays
    static uint8_t FRAME_0[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x00, 0x80, 0x06, 0x00, 0x20, 0x89, 0x01, 0x00, 0x08, 0x91, 
        0x01, 0x00, 0x08, 0x93, 0x01, 0x00, 0x08, 0x95, 0x01, 0x00, 0x08, 0x97, 0x01, 0x00, 0x08, 0x99, 
        0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x9B, 0x01, 0x00, 0x08, 0x9D, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
        0x9F, 0x01, 0x00, 0x08, 0xA1, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 
        0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 
        0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 
        0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 
        0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0x68, 0x8C, 0xFD, 0x6F, 0xBB
    };

    static uint8_t FRAME_1[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x01, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 
        0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 
        0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 
        0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 
        0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 
        0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 
        0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0xA3, 0x01, 0x00, 0x08, 0x00, 
        0xF0, 0x02, 0xF8, 0x00, 0xF0, 0x3A, 0xF8, 0x0A, 0xA0, 0x90, 0xE8, 0x00, 0x0C, 0x82, 0x44, 0x83, 
        0x44, 0xAA, 0xF1, 0x26, 0x43, 0xCA, 0x7D, 0xBB
    };

    static uint8_t FRAME_2[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x02, 0x01, 0x07, 0xDA, 0x45, 0x01, 0xD1, 0x00, 0xF0, 0x2F, 
        0xF8, 0xAF, 0xF2, 0x09, 0x0E, 0xBA, 0xE8, 0x0F, 0x00, 0x13, 0xF0, 0x01, 0x0F, 0x18, 0xBF, 0xFB, 
        0x1A, 0x43, 0xF0, 0x01, 0x03, 0x18, 0x47, 0xE0, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x10, 
        0x3A, 0x24, 0xBF, 0x78, 0xC8, 0x78, 0xC1, 0xFA, 0xD8, 0x52, 0x07, 0x24, 0xBF, 0x30, 0xC8, 0x30, 
        0xC1, 0x44, 0xBF, 0x04, 0x68, 0x0C, 0x60, 0x70, 0x47, 0x00, 0x00, 0x00, 0x23, 0x00, 0x24, 0x00, 
        0x25, 0x00, 0x26, 0x10, 0x3A, 0x28, 0xBF, 0x78, 0xC1, 0xFB, 0xD8, 0x52, 0x07, 0x28, 0xBF, 0x30, 
        0xC1, 0x48, 0xBF, 0x0B, 0x60, 0x70, 0x47, 0x1F, 0xB5, 0x1F, 0xBD, 0x10, 0xB5, 0x10, 0xBD, 0x00, 
        0xF0, 0x31, 0xF8, 0x11, 0x46, 0xFF, 0xF7, 0xF7, 0xFF, 0x00, 0xF0, 0xF0, 0xF9, 0x00, 0xF0, 0x4F, 
        0xF8, 0x03, 0xB4, 0xFF, 0xF7, 0xF2, 0xFF, 0xDA, 0x9F, 0xF6, 0xD1, 0xBB
    };

    static uint8_t FRAME_3[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x03, 0x03, 0xBC, 0x00, 0xF0, 0x57, 0xF8, 0x00, 0x00, 0x09, 
        0x48, 0x80, 0x47, 0x09, 0x48, 0x00, 0x47, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 
        0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0xFE, 0xE7, 0x04, 0x48, 0x05, 0x49, 0x05, 
        0x4A, 0x06, 0x4B, 0x70, 0x47, 0x00, 0x00, 0x7D, 0x04, 0x00, 0x08, 0xED, 0x00, 0x00, 0x08, 0x80, 
        0x00, 0x00, 0x20, 0x80, 0x06, 0x00, 0x20, 0x80, 0x02, 0x00, 0x20, 0x80, 0x02, 0x00, 0x20, 0x70, 
        0x47, 0x70, 0x47, 0x70, 0x47, 0x75, 0x46, 0x00, 0xF0, 0x2C, 0xF8, 0xAE, 0x46, 0x05, 0x00, 0x69, 
        0x46, 0x53, 0x46, 0x20, 0xF0, 0x07, 0x00, 0x85, 0x46, 0x18, 0xB0, 0x20, 0xB5, 0xFF, 0xF7, 0xDD, 
        0xFF, 0xBD, 0xE8, 0x20, 0x40, 0x4F, 0xF0, 0x00, 0x06, 0x4F, 0xF0, 0x00, 0x07, 0x4F, 0xF0, 0x00, 
        0x08, 0x4F, 0xF0, 0x00, 0x0B, 0x21, 0xF0, 0x43, 0xD6, 0x04, 0x8D, 0xBB
    };

    static uint8_t FRAME_4[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x04, 0x07, 0x01, 0xAC, 0x46, 0xAC, 0xE8, 0xC0, 0x09, 0xAC, 
        0xE8, 0xC0, 0x09, 0xAC, 0xE8, 0xC0, 0x09, 0xAC, 0xE8, 0xC0, 0x09, 0x8D, 0x46, 0x70, 0x47, 0x10, 
        0xB5, 0x04, 0x46, 0xAF, 0xF3, 0x00, 0x80, 0x20, 0x46, 0xBD, 0xE8, 0x10, 0x40, 0xFF, 0xF7, 0xA8, 
        0xBF, 0x00, 0x00, 0x00, 0x48, 0x70, 0x47, 0x20, 0x00, 0x00, 0x20, 0x01, 0x49, 0x18, 0x20, 0xAB, 
        0xBE, 0xFE, 0xE7, 0x26, 0x00, 0x02, 0x00, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x41, 0x02, 0x46, 0x00, 
        0x25, 0x00, 0x26, 0x00, 0x20, 0x00, 0x23, 0x00, 0x24, 0x00, 0x27, 0x91, 0xF8, 0x03, 0xC0, 0x0C, 
        0xF0, 0x0F, 0x05, 0x91, 0xF8, 0x03, 0xC0, 0x0C, 0xF0, 0x10, 0x0C, 0xBC, 0xF1, 0x00, 0x0F, 0x03, 
        0xD0, 0x91, 0xF8, 0x02, 0xC0, 0x4C, 0xEA, 0x05, 0x05, 0x91, 0xF8, 0x00, 0xC0, 0xBC, 0xF1, 0x00, 
        0x0F, 0x31, 0xD0, 0x14, 0x68, 0x00, 0x20, 0x6B, 0xB0, 0xB1, 0x40, 0xBB
    };

    static uint8_t FRAME_5[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x05, 0x2B, 0xE0, 0x4F, 0xF0, 0x01, 0x0C, 0x0C, 0xFA, 0x00, 
        0xF3, 0xB1, 0xF8, 0x00, 0xC0, 0x0C, 0xEA, 0x03, 0x06, 0x9E, 0x42, 0x20, 0xD1, 0x83, 0x00, 0x4F, 
        0xF0, 0x0F, 0x0C, 0x0C, 0xFA, 0x03, 0xF7, 0xBC, 0x43, 0x05, 0xFA, 0x03, 0xFC, 0x4C, 0xEA, 0x04, 
        0x04, 0x91, 0xF8, 0x03, 0xC0, 0xBC, 0xF1, 0x28, 0x0F, 0x06, 0xD1, 0x4F, 0xF0, 0x01, 0x0C, 0x0C, 
        0xFA, 0x00, 0xFC, 0xC2, 0xF8, 0x14, 0xC0, 0x0A, 0xE0, 0x91, 0xF8, 0x03, 0xC0, 0xBC, 0xF1, 0x48, 
        0x0F, 0x05, 0xD1, 0x4F, 0xF0, 0x01, 0x0C, 0x0C, 0xFA, 0x00, 0xFC, 0xC2, 0xF8, 0x10, 0xC0, 0x40, 
        0x1C, 0x08, 0x28, 0xD1, 0xD3, 0x14, 0x60, 0xB1, 0xF8, 0x00, 0xC0, 0xBC, 0xF1, 0xFF, 0x0F, 0x34, 
        0xDD, 0x54, 0x68, 0x00, 0x20, 0x2E, 0xE0, 0x00, 0xF1, 0x08, 0x0C, 0x4F, 0xF0, 0x01, 0x08, 0x08, 
        0xFA, 0x0C, 0xF3, 0xB1, 0xF8, 0x00, 0xC0, 0x39, 0xDB, 0x63, 0xFB, 0xBB
    };

    static uint8_t FRAME_6[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x06, 0x0C, 0xEA, 0x03, 0x06, 0x9E, 0x42, 0x21, 0xD1, 0x83, 
        0x00, 0x4F, 0xF0, 0x0F, 0x0C, 0x0C, 0xFA, 0x03, 0xF7, 0xBC, 0x43, 0x05, 0xFA, 0x03, 0xFC, 0x4C, 
        0xEA, 0x04, 0x04, 0x91, 0xF8, 0x03, 0xC0, 0xBC, 0xF1, 0x28, 0x0F, 0x05, 0xD1, 0x00, 0xF1, 0x08, 
        0x0C, 0x08, 0xFA, 0x0C, 0xF8, 0xC2, 0xF8, 0x14, 0x80, 0x91, 0xF8, 0x03, 0xC0, 0xBC, 0xF1, 0x48, 
        0x0F, 0x07, 0xD1, 0x00, 0xF1, 0x08, 0x0C, 0x4F, 0xF0, 0x01, 0x08, 0x08, 0xFA, 0x0C, 0xF8, 0xC2, 
        0xF8, 0x10, 0x80, 0x40, 0x1C, 0x08, 0x28, 0xCE, 0xD3, 0x54, 0x60, 0xBD, 0xE8, 0xF0, 0x81, 0x02, 
        0x46, 0x00, 0x20, 0x93, 0x68, 0x0B, 0x40, 0x0B, 0xB1, 0x01, 0x20, 0x00, 0xE0, 0x00, 0x20, 0x70, 
        0x47, 0x41, 0x61, 0x70, 0x47, 0x01, 0x61, 0x70, 0x47, 0x00, 0x00, 0x29, 0xB1, 0x06, 0x4A, 0x92, 
        0x69, 0x02, 0x43, 0x04, 0x4B, 0x9A, 0x61, 0xBF, 0xE8, 0x42, 0x92, 0xBB
    };

    static uint8_t FRAME_7[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x07, 0x04, 0xE0, 0x03, 0x4A, 0x92, 0x69, 0x82, 0x43, 0x01, 
        0x4B, 0x9A, 0x61, 0x70, 0x47, 0x00, 0x00, 0x00, 0x10, 0x02, 0x40, 0x10, 0xB5, 0x00, 0xF0, 0x01, 
        0xF8, 0x10, 0xBD, 0x0C, 0xB5, 0x00, 0x20, 0x01, 0x90, 0x00, 0x90, 0x33, 0x48, 0x00, 0x68, 0x40, 
        0xF4, 0x80, 0x30, 0x31, 0x49, 0x08, 0x60, 0x00, 0xBF, 0x30, 0x48, 0x00, 0x68, 0x00, 0xF4, 0x00, 
        0x30, 0x00, 0x90, 0x01, 0x98, 0x40, 0x1C, 0x01, 0x90, 0x00, 0x98, 0x18, 0xB9, 0x01, 0x98, 0xB0, 
        0xF5, 0xA0, 0x6F, 0xF1, 0xD1, 0x29, 0x48, 0x00, 0x68, 0x00, 0xF4, 0x00, 0x30, 0x10, 0xB1, 0x01, 
        0x20, 0x00, 0x90, 0x01, 0xE0, 0x00, 0x20, 0x00, 0x90, 0x00, 0x98, 0x01, 0x28, 0x43, 0xD1, 0x23, 
        0x48, 0x00, 0x68, 0x40, 0xF0, 0x10, 0x00, 0x21, 0x49, 0x08, 0x60, 0x08, 0x46, 0x00, 0x68, 0x20, 
        0xF0, 0x07, 0x00, 0x08, 0x60, 0x08, 0x46, 0x8A, 0xFA, 0xD1, 0x25, 0xBB
    };

    static uint8_t FRAME_8[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x08, 0x00, 0x68, 0x40, 0xF0, 0x02, 0x00, 0x08, 0x60, 0x1A, 
        0x48, 0x40, 0x68, 0x19, 0x49, 0x48, 0x60, 0x08, 0x46, 0x40, 0x68, 0x48, 0x60, 0x08, 0x46, 0x40, 
        0x68, 0x40, 0xF4, 0x80, 0x60, 0x48, 0x60, 0x08, 0x46, 0x40, 0x68, 0x20, 0xF4, 0x7C, 0x10, 0x48, 
        0x60, 0x08, 0x46, 0x40, 0x68, 0x40, 0xF4, 0xE8, 0x10, 0x48, 0x60, 0x08, 0x46, 0x00, 0x68, 0x40, 
        0xF0, 0x80, 0x70, 0x08, 0x60, 0x00, 0xBF, 0x0C, 0x48, 0x00, 0x68, 0x00, 0xF0, 0x00, 0x70, 0x00, 
        0x28, 0xF9, 0xD0, 0x09, 0x48, 0x40, 0x68, 0x20, 0xF0, 0x03, 0x00, 0x07, 0x49, 0x48, 0x60, 0x08, 
        0x46, 0x40, 0x68, 0x40, 0xF0, 0x02, 0x00, 0x48, 0x60, 0x00, 0xBF, 0x03, 0x48, 0x40, 0x68, 0x00, 
        0xF0, 0x0C, 0x00, 0x08, 0x28, 0xF9, 0xD1, 0x0C, 0xBD, 0x00, 0x00, 0x00, 0x10, 0x02, 0x40, 0x00, 
        0x20, 0x02, 0x40, 0x10, 0xB5, 0x13, 0x48, 0x55, 0xB3, 0x0D, 0x87, 0xBB
    };

    static uint8_t FRAME_9[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x09, 0x00, 0x68, 0x40, 0xF0, 0x01, 0x00, 0x11, 0x49, 0x08, 
        0x60, 0x08, 0x46, 0x40, 0x68, 0x10, 0x49, 0x08, 0x40, 0x0E, 0x49, 0x48, 0x60, 0x08, 0x46, 0x00, 
        0x68, 0x0E, 0x49, 0x08, 0x40, 0x0B, 0x49, 0x08, 0x60, 0x08, 0x46, 0x00, 0x68, 0x20, 0xF4, 0x80, 
        0x20, 0x08, 0x60, 0x08, 0x46, 0x40, 0x68, 0x20, 0xF4, 0xFE, 0x00, 0x48, 0x60, 0x4F, 0xF4, 0x1F, 
        0x00, 0x88, 0x60, 0xFF, 0xF7, 0x6A, 0xFF, 0x4F, 0xF0, 0x00, 0x60, 0x04, 0x49, 0x08, 0x60, 0x10, 
        0xBD, 0x00, 0x00, 0x00, 0x10, 0x02, 0x40, 0x00, 0x00, 0xFF, 0xF8, 0xFF, 0xFF, 0xF6, 0xFE, 0x08, 
        0xED, 0x00, 0xE0, 0x08, 0xB5, 0x01, 0x21, 0x0C, 0x20, 0xFF, 0xF7, 0x47, 0xFF, 0x10, 0x20, 0x8D, 
        0xF8, 0x03, 0x00, 0x7F, 0x20, 0xAD, 0xF8, 0x00, 0x00, 0x03, 0x20, 0x8D, 0xF8, 0x02, 0x00, 0x69, 
        0x46, 0x0E, 0x48, 0xFF, 0xF7, 0xA1, 0xFE, 0x5C, 0xAE, 0x7F, 0xDD, 0xBB
    };

    static uint8_t FRAME_10[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x0A, 0x10, 0x20, 0x8D, 0xF8, 0x03, 0x00, 0x03, 0x20, 0xAD, 
        0xF8, 0x00, 0x00, 0x8D, 0xF8, 0x02, 0x00, 0x69, 0x46, 0x09, 0x48, 0xFF, 0xF7, 0x95, 0xFE, 0x48, 
        0x20, 0x8D, 0xF8, 0x03, 0x00, 0x40, 0x20, 0xAD, 0xF8, 0x00, 0x00, 0x03, 0x20, 0x8D, 0xF8, 0x02, 
        0x00, 0x69, 0x46, 0x02, 0x48, 0xFF, 0xF7, 0x88, 0xFE, 0x08, 0xBD, 0x00, 0x08, 0x01, 0x40, 0x00, 
        0x0C, 0x01, 0x40, 0x00, 0x21, 0x07, 0xE0, 0x00, 0x22, 0x00, 0xE0, 0x52, 0x1C, 0x42, 0xF6, 0xFF, 
        0x23, 0x9A, 0x42, 0xFA, 0xD3, 0x49, 0x1C, 0x81, 0x42, 0xF5, 0xD3, 0x70, 0x47, 0xFF, 0xF7, 0xC1, 
        0xFF, 0x01, 0xE0, 0x00, 0xF0, 0x02, 0xF8, 0xFC, 0xE7, 0x00, 0x00, 0x10, 0xB5, 0x20, 0x48, 0x00, 
        0x78, 0x20, 0x49, 0x08, 0x70, 0x40, 0x21, 0x1F, 0x48, 0xFF, 0xF7, 0xF1, 0xFE, 0x1C, 0x49, 0x08, 
        0x70, 0x08, 0x46, 0x00, 0x78, 0x40, 0xB9, 0x12, 0x34, 0xB6, 0x20, 0xBB
    };

    static uint8_t FRAME_11[] = {
        0xAA, 0x02, 0x02, 0x00, 0x82, 0x00, 0x0B, 0x1A, 0x48, 0x00, 0x78, 0x01, 0x28, 0x04, 0xD1, 0x1A, 
        0x48, 0x00, 0x68, 0x40, 0x1C, 0x19, 0x49, 0x08, 0x60, 0x01, 0x21, 0x16, 0x48, 0xFF, 0xF7, 0xE8, 
        0xFE, 0x01, 0x20, 0xFF, 0xF7, 0xCE, 0xFF, 0x14, 0x48, 0x00, 0x68, 0x0A, 0x21, 0x90, 0xFB, 0xF1, 
        0xF0, 0x13, 0x49, 0x08, 0x5C, 0x13, 0x49, 0x08, 0x60, 0x01, 0x21, 0x0E, 0x48, 0xFF, 0xF7, 0xDA, 
        0xFE, 0x02, 0x21, 0x0C, 0x48, 0xFF, 0xF7, 0xD4, 0xFE, 0x01, 0x20, 0xFF, 0xF7, 0xBA, 0xFF, 0x0A, 
        0x48, 0x00, 0x68, 0x0A, 0x21, 0x90, 0xFB, 0xF1, 0xF2, 0x01, 0xFB, 0x12, 0x00, 0x08, 0x49, 0x08, 
        0x5C, 0x08, 0x49, 0x08, 0x60, 0x02, 0x21, 0x03, 0x48, 0xFF, 0xF7, 0xC4, 0xFE, 0x10, 0xBD, 0x1D, 
        0x00, 0x00, 0x20, 0x1C, 0x00, 0x00, 0x20, 0x00, 0x0C, 0x01, 0x40, 0x0C, 0x00, 0x00, 0x20, 0x00, 
        0x00, 0x00, 0x20, 0x0C, 0x08, 0x01, 0x40, 0xD3, 0xF6, 0x4F, 0x57, 0xBB
    };

    static uint8_t FRAME_12[] = {
        0xAA, 0x02, 0x02, 0x00, 0x42, 0x00, 0x0C, 0x20, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 
        0x00, 0x00, 0x00, 0x28, 0x01, 0x00, 0x08, 0x40, 0x06, 0x00, 0x08, 0x20, 0x00, 0x00, 0x20, 0x60, 
        0x06, 0x00, 0x00, 0x44, 0x01, 0x00, 0x08, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 
        0x90, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x12, 0xB9, 0x38, 0xF7, 0xBB
    };

    {
        memset(&OTA_FSM_Data, 0, sizeof(OTA_FSM_Data));
        // frame_len = sizeof(FRAME_1);
        // printf("Length: %u \n",frame_len );

        // LORA_Frame_Status_t decode_status = loRaDecodeFrame(FRAME_1, frame_len, &OTA_FSM_Data);

        // printf("FRAME_0 result: %d\n", decode_status);
        // // TEST_ASSERT_EQUAL(LORA_STATUS_DECODE_FRAME_SUCCESS, decode_status);

        // printf("FRAME_2 seq: %u\n", ota_node.expected_seq);
        // st = loRaOtaReceiveHandler(OTA_TYPE_DATA, OTA_FSM_Data.data_payload, OTA_FSM_Data.data_len);
        // TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_DATA_SUCCESS, st, "DATA frame processing failed");
    }

    // struct {
    //     uint8_t *data;
    //     uint16_t size;
    //     int seq;
    //     const char *name;
    // }  
    // test_frames[] = {
    //     {FRAME_0, sizeof(FRAME_0), 0, "FRAME_0"},
    //     {FRAME_1, sizeof(FRAME_1), 1, "FRAME_1"},
    //     {FRAME_2, sizeof(FRAME_2), 2, "FRAME_2"},
    //     {FRAME_3, sizeof(FRAME_3), 3, "FRAME_3"},
    //     {FRAME_4, sizeof(FRAME_4), 4, "FRAME_4"},
    //     {FRAME_5, sizeof(FRAME_5), 5, "FRAME_5"},
    //     {FRAME_6, sizeof(FRAME_6), 6, "FRAME_6"},
    //     {FRAME_7, sizeof(FRAME_7), 7, "FRAME_7"},
    //     {FRAME_8, sizeof(FRAME_8), 8, "FRAME_8"},
    //     {FRAME_9, sizeof(FRAME_9), 9, "FRAME_9"},
    //     {FRAME_10, sizeof(FRAME_10), 10, "FRAME_10"},
    //     {FRAME_11, sizeof(FRAME_11), 11, "FRAME_11"},
    //     {FRAME_12, sizeof(FRAME_12), 12, "FRAME_12"}
    // };
    // {
    //     printf("Testing all frames from log...\n");
    //     for (int i = 0; i < 13; i++) 
    //     {
    //         printf("\n--- Testing %s (seq=%d, size=%d bytes) ---\n", 
    //             test_frames[i].name, test_frames[i].seq, test_frames[i].size);
            
    //         // Reset data
    //         memset(&OTA_FSM_Data, 0, sizeof(OTA_FSM_Data));
    //         frame_len = test_frames[i].size;
            
    //         // Gọi hàm decode của bạn - CHÍNH XÁC NHƯ BẠN YÊU CẦU
    //         LORA_Frame_Status_t decode_status = loRaDecodeFrame(test_frames[i].data, frame_len, &OTA_FSM_Data);
            
    //         // In kết quả
    //         printf("Decode Status: %d\n", decode_status);
    //         printf("Frame Size: %d bytes\n", frame_len);
            
    //         // In thêm thông tin nếu decode thành công
    //         if (decode_status == LORA_STATUS_DECODE_FRAME_SUCCESS) {
    //             printf("✓ SUCCESS - Frame decoded successfully\n");
    //             // Có thể in thêm thông tin chi tiết nếu cần
    //         } else {
    //             printf("✗ FAILED - Error code: %d\n", decode_status);
    //         }

    //         st = loRaOtaReceiveHandler(OTA_TYPE_DATA, OTA_FSM_Data.data_payload, OTA_FSM_Data.data_len);
       
    //         TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_DATA_SUCCESS, st, "DATA frame processing failed");
    //     }
    // }

    // // const size_t all_data_fr_len = sizeof(all_data_fr)/sizeof(all_data_fr[0]);

    // memset(&OTA_FSM_Data, 0, sizeof(OTA_FSM_Data));
    // frame_len = sizeof(FR_DATA_1);

    // LORA_Frame_Status_t decode_status = loRaDecodeFrame(FR_DATA_1, frame_len, &OTA_FSM_Data);
    // TEST_ASSERT_EQUAL(LORA_STATUS_DECODE_FRAME_SUCCESS, decode_status);
        
    
    
    // for (size_t i = 0; i < 13; ++i) {
    //     memset(&OTA_FSM_Data, 0, sizeof(OTA_FSM_Data));
    //     frame_len = all_frame_lengths[i];
    //     printf("\n Length frame %u \n", frame_len);
    //     LORA_Frame_Status_t decode_status = loRaDecodeFrame(all_data_fr[i], frame_len, &OTA_FSM_Data);
    //     TEST_ASSERT_EQUAL(LORA_STATUS_DECODE_FRAME_SUCCESS, decode_status);
    //     st = loRaOtaReceiveHandler(OTA_TYPE_DATA, OTA_FSM_Data.data_payload, OTA_FSM_Data.data_len);
    //     TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_DATA_SUCCESS, st, "DATA frame processing failed");
    // }
    
   /* After receiving all data frames we expect WAIT_END */
    // TEST_ASSERT_EQUAL_MESSAGE(OTA_NODE_WAIT_END, ota_node.expected_state, "State must be WAIT_END after DATA frames"); 

    // /* --- END frame (from log) --- */
    // static const uint8_t FR_END[] = {
    //     0xAA,0x02,0x04,0x00,0x01, 0x01, 0x92,0xFB,0x56,0xCB, 0xBB
    // };
    // {
    //     uint16_t plen = FRAME_PAYLEN(FR_END);
    //     uint8_t *p = FRAME_PAYPTR(FR_END);
    //     st = loRaOtaReceiveHandler(OTA_TYPE_END, p, plen);
    //     TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_END_SUCCESS, st, "END failed");
    // }

    // /* --- SIGNAL_UPDATE frame (from log) --- */
    // static const uint8_t FR_SIGUPD[] = {
    //     0xAA,0x02,0x05,0x00,0x08,
    //     0x08,0x00,0x00,0x00, 0x08,0x00,0x00,0xED, 0xC8,0x61,0x73,0x1C,
    //     0xBB
    // };
    // {
    //     /* ensure CRC check passes in your handler if it compares against expected; set expected to actual */
    //     ota_node.expected_crc = crc_fast(ota_node.fw_buffer, ota_node.received_bytes);
    //     uint16_t plen = FRAME_PAYLEN(FR_SIGUPD);
    //     uint8_t *p = FRAME_PAYPTR(FR_SIGUPD);
    //     st = loRaOtaReceiveHandler(OTA_TYPE_SIGNAL_UPDATE, p, plen);
    //     TEST_ASSERT_EQUAL_MESSAGE(LORA_OTA_STATUS_PROCESS_SIGNAL_UPDATE_SUCCESS, st, "SIGNAL_UPDATE failed");
    //     TEST_ASSERT_EQUAL_MESSAGE(OTA_NODE_DONE, ota_node.state, "Node not in DONE after SIGNAL_UPDATE");
    // }

    free(ota_node.expected_fw_buffer);
}


#endif // TEST
